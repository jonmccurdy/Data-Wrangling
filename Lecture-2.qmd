# Introducing Databases

In the real world, data is rarely small or neatly organized, so knowing how to work with databases is essential for any data scientist. Databases help us store, organize, and access large amounts of data efficiently. They can contain multiple related tables, which keeps data consistent and avoids duplication. Databases also let us query data quickly, handle large datasets, and allow multiple users to access the data at the same time. In this lecture, we’ll use a database stored on our local computer, but the skills and syntax apply to databases on company servers as well.

```{r}
#| warning: false

# If you do not have the following installed already you will need to do that first
# install.packages(c("DBI", "RSQLite", "dplyr", "dbplyr"))

library(DBI)
library(RSQLite)
library(dplyr)
library(dbplyr)
```

Download the following sample database that we will be using for this lecture. I recommend creating a "Data-330" folder that will house all of the files that we use throughout this semester. This can be done by creating an R project and moving the file to the correct folder. 

::: {.callout-tip}
## Supplemental Material
<a href="college.db" download>
College Database we will be using
</a>
:::

<!--
set.seed(123)

# Names
first_names <- c("Alice","Ben","Claire","Danny","Evelyn","Frank","Grant",
                 "Hannah","Isabela","Jake","Kate","Liam","Mary","Nate",
                 "Olivia","Peter","Quinn","Rachel","Stacy","Thomas",
                 "Uma","Victor","Wendy","Xavier","Yara","Zach")

last_names <- c("Anderson","Brown","Clark","Davis","Evans","Foster","Green",
                "Hughes","Ingram","Johnson","King","Lopez","Miller","Nelson",
                "Owens","Parker","Quincy","Roberts","Stevens","Turner",
                "Underwood","Vasquez","Williams","Xiong","Young","Zimmerman")

# Majors and years
majors <- c("Data Science","Biology","History","Computer Science","Math",
            "Psychology","Business","English")

years <- c("Freshman","Sophomore","Junior","Senior")

# Students
students <- data.frame(
  student_id = 1:50,
  name = paste(sample(first_names, 50, replace=TRUE),
               sample(last_names, 50, replace=TRUE)),
  major = sample(majors, 50, replace=TRUE),
  gpa = round(runif(50, 2.5, 4.0), 2),
  year = sample(years, 50, replace=TRUE)
)

# Courses
courses <- data.frame(
  course_id = 1:10,
  course_name = c("Intro to R","Biology 101","World History",
                  "Algorithms","Calculus I","Psychology of Learning",
                  "Microeconomics","Literary Analysis","Statistics",
                  "Machine Learning"),
  credits = sample(3:4, 10, replace=TRUE)
)

# Enrollments (each student takes 2–5 courses)
enrollments <- do.call(rbind, lapply(students$student_id, function(sid) {
  n_courses <- sample(2:5, 1)
  course_ids <- sample(courses$course_id, n_courses)
  grades <- sample(c("A","A-","B+","B","B-","C+","C"), n_courses, replace=TRUE)
  data.frame(student_id = sid, course_id = course_ids, grade = grades)
}))

# -----------------------------
# Write Data into Database
# -----------------------------
dbWriteTable(con, "Students", students, append=TRUE)
dbWriteTable(con, "Courses", courses, append=TRUE)
dbWriteTable(con, "Enrollments", enrollments, append=TRUE)
-->

## Connecting to a Database

Now that we have the database that we would like to use we can open a connection to it. This is important because the database itself is not loaded into R; instead, the connection object allows us to read, write, and query data without loading the entire database into memory. To make this connection we will use the `dbConnect()` function. The `SQLite()` command tells R that the database we will be accessing is a SQLite database (there are many different kinds of databases, we will stick with this one for now). Finally, the "college.db" command is the path to the database file in the current working directory that we would like to access. 

```{r}
db_con <- dbConnect(SQLite(), "college.db")
```

## Database Properties

Once we have connected to the database we will see it appear in our global environment. Notice though that if you click the object no data will appear, queries are required to pull the data into R. If you want to see what tables are present in the database you can use the `dbListTables()` function with your database connection passed into it. The output shows that the database currently contains three tables: `Courses`, `Enrollments`, and `Students` 

```{r}
dbListTables(db_con)
```

If we want to dive further into the tables and see each table contains we can use the `dbListFields()`function, passing the database connection and the table name as arguments. In the example below we can see the `Courses` table contains the course\_id, the course\_name, and the number of credits it is. Likewise we can learn about the other tables using the same code.

```{r}
dbListFields(db_con, "Courses")
dbListFields(db_con, "Enrollments")
dbListFields(db_con, "Students")
```

## Accessing Tables

If we want to access the tables within the database we can use the `tbl()` function while calling both the database connection and the table name. Notice that the output from tbl() does not load the full table into R; it only creates a reference to the table and shows a preview of the first few rows. This can be seen with the "Enrollments" and "Students" tables as it is not quite sure how many rows are present. 

```{r}
tbl(db_con, "Courses")
tbl(db_con, "Enrollments")
tbl(db_con, "Students")
```

If we want to actually pull the table from the database and have it accessible in R then we will need to use the `collect()` function. In the code below we can see that we pull the data from the database and save it to some variable. We can then look at the first few observations (you can look at all of it, I am only looking at the first few as I do not want to display them all). We can also look at the dimensions of the table, which shows that there are 50 rows in the students at the college. 

```{r}
students_table <- tbl(db_con, "Students") |> collect()
students_table |> head()
students_table |> dim()
```

## Filtering a Table

Typically with databases we use a language called SQL (pronounced either "S-Q-L" or "sequel") which allows us to efficiently query a database. We can either use that language, or dplyr to filter, sort, and summarize the dataset. We can see both examples below where we are selecting all of the columns from the Students table and showing only the rows where the gpa is greater than 3.5. When we use the `dbGetQuery()` function we pass the database connection and the SQL query we want to run and the output is a dataframe in R. When we use the `tbl()` function alongside the `dplyr` commands the output is a reference to a table within the database. We would need to use the `collect()` function to load the actual data into R. The second way can be beneficial with large datasets as we do not pull the data into R until we explicitly call collect(), which can save memory and computation time.

```{r}
dbGetQuery(db_con, "SELECT * FROM Students WHERE gpa > 3.5")

tbl(db_con, "Students") |> filter(gpa > 3.5)
```

## Arranging a Table

In the code below we select 3 columns and then arrange (order) them by their gpa in descending order. We save the result to a variable and display only the first few rows to keep the output concise.

```{r}
order_gpa_query <- "SELECT student_id, name, gpa FROM Students ORDER BY gpa DESC"
ordered_gpa <- dbGetQuery(db_con, order_gpa_query)
head(ordered_gpa)

tbl(db_con, "Students") |> select(student_id, name, gpa) |> 
        arrange(desc(gpa)) |> 
        collect()
```

## Joining Tables

Since we are working with multiple tables, it might be beneficial to join them together. Before we attempt this with our database we will look at a basic example to try and see how it can be done. In the code below we have 5 different products, showing the product id along with the product name, and 6 different orders, showing the order number, product id, and the quantity bought. 

```{r}
products <- data.frame(
  product_id = 1:5,
  product_name = c("Laptop", "Phone", "Tablet", "Monitor", "Candybar")
)

# Orders table
orders <- data.frame(
  order_id = 101:106,
  product_id = c(1, 2, 2, 3, 4, 13),
  quantity = c(2, 1, 3, 2, 1, 1)
)

products
orders
```

Keeping these tables separate instead of combining them into one large table avoids duplication, simplifies updates (e.g., changing a product name), makes data easier to manage, and facilitates analysis.

We can notice that product\_id is present in both tables, allowing us to combine the two tables using that variable as the common element. For this we will use the `inner_join()` function which will return only the rows that match in both tables. Notice that the product "Candybar" did not appear in the joined list, and neither did order "106" which bought product "13" (as these orders/products are not present in both lists). There are other types of join functions as well, such as left, right, and full joins, which combine tables in a way that preserves unmatched rows from one or both tables depending on the type of join.

```{r}
inner_join(orders, products, by = "product_id")
```

In the code below we show both how it can be done in SQL and dplyr. In the SQL query, we join `Students` with `Enrollments` using `student_id` as the common key, and then join `Enrollments` with `Courses` using `course_id.` After that we are only selecting the `name`, `course_name`, and `grade` variables.

```{r}
combine_query <- "SELECT Students.name, Courses.course_name, Enrollments.grade
                  FROM Students
                  JOIN Enrollments ON Students.student_id = Enrollments.student_id
                  JOIN Courses ON Enrollments.course_id = Courses.course_id"

combined_tables <- dbGetQuery(db_con, combine_query)
head(combined_tables)

# dplyr
tbl(db_con, "Students") |>
  inner_join(tbl(db_con, "Enrollments"), by = "student_id") |>
  inner_join(tbl(db_con, "Courses"), by = "course_id") |>
  select(name, course_name, grade)
```

## Grouping and Summarising

In addition to selecting, filtering, and arranging the data, we can also summarize and group by different variables. In the code below we look at the "Enrollments" table, group by `student_id` to count how many courses each student is enrolled in. This allows us to count how many courses each student is enrolled in during the semester.

```{r}
classes_per_student_query <- "SELECT student_id, COUNT(course_id)
                              FROM Enrollments
                              GROUP BY student_id"

students_per_class <- dbGetQuery(db_con, classes_per_student_query)
head(students_per_class)

tbl(db_con, "Enrollments") |> 
  group_by(student_id) |>
  summarise(count = n())
```

We can also count the number of students enrolled in each course by running the following code:

```{r}
students_per_course_query <-   "SELECT course_id, COUNT(student_id)
                               FROM Enrollments
                               GROUP BY course_id"

students_per_course <- dbGetQuery(db_con, students_per_course_query)
head(students_per_course)

tbl(db_con, "Enrollments") |> 
  group_by(course_id) |>
  summarise(count = n())
```

## Disconnecting from the Database

Once we have finished accessing a database, it is good practice to disconnect from it. This frees up resources on our computer (and the server we are connecting to). It also prevents us from accidentally writing or modifying the database and ensures other users can access and modify the data without issues.


```{r}
dbDisconnect(db_con)
```
