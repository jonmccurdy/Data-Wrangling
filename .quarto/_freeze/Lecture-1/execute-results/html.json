{
  "hash": "436dafda647826e167b101517d77ce92",
  "result": {
    "engine": "knitr",
    "markdown": "# Data Exploration Refresher\n\nSo far in your data science journey you have experienced cleaning data, visualizing data, communicating the data, and maybe even modeling the data. This is typically what we call the \\textit{Data Science Life-cycle}, an iterative process where we acquire, clean, explore, model, and communicate the data. Throughout this course we will aim to accomplish all of these tasks using more sophisticated methods. Before we dive too far into Data Wrangling we should probably refresh ourselves on how best to clean and transform a dataset using \\textit{tidyr} and \\textit{dplyr}. This lecture will be requiring you to have the `tidyr`, `dplyr` and `MSMU` libraries already installed, so if you have not then you will need to do so by using the `install.packages(\"LIBRARY_NAME\")` command. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(MSMU)\n```\n:::\n\n\n## Dplyr\n\nThe `dplyr` library contains powerful tools that make cleaning, sorting, filtering, and manipulating datasets easy. To see this in action we will look at the *airquality* dataset which is available in base R. Before we dive into the functions, we should remind ourselves that the `|>` pipe function allows us to take a dataframe and pass it into a function without having to specify the dataframe. Think of the pipe as saying ‘and then.’ We take this dataset, and then we select these columns, and then we rename one of them, and then.... This makes the code much cleaner and easier to interpret/write.\n\n### Select\n\nThe first function we should familiarize ourselves with is the `select()` function, which allows us to *select* which columns we want to include in the dataframe. In the code below we can see that original dataset had 17 columns, but knowing that all were not vital for us we only selected 5 that we knew we were going to work with. \n\n<!--\nairquality <- tibble(airquality)\n\nhead(airquality)\n\nairquality |> filter(Wind > 17)\n\nairquality |> filter(Wind > 17 | Ozone <= 7)\n\nairquality |> filter(Wind > 17 , Ozone <= 7)\n\n\nairquality |> filter(Wind > 17) |> select(Month, Day, Wind, Temp)\n-->\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounty_data <- tibble(county_data)\n\ncounty_data\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3,142 × 17\n   state   name        fips    pop households median_age age_over_18 age_over_65\n   <chr>   <chr>      <int>  <int>      <int>      <dbl>       <dbl>       <dbl>\n 1 Alabama Autauga C…  1001  55380      21397       38.2        76.2        15  \n 2 Alabama Baldwin C…  1003 212830      80930       43          78.3        20  \n 3 Alabama Barbour C…  1005  25361       9345       40.4        79.1        18.6\n 4 Alabama Bibb Coun…  1007  22493       6891       40.9        79.4        15.9\n 5 Alabama Blount Co…  1009  57681      20847       40.7        76.8        17.9\n 6 Alabama Bullock C…  1011  10248       3521       40.2        79.2        16  \n 7 Alabama Butler Co…  1013  19828       6506       40.8        77.5        19.7\n 8 Alabama Calhoun C…  1015 114618      44605       39.6        78.2        17.2\n 9 Alabama Chambers …  1017  33660      13448       42          79          19.2\n10 Alabama Cherokee …  1019  25903      10737       46.5        79.8        22.4\n# ℹ 3,132 more rows\n# ℹ 9 more variables: hs_grad <dbl>, bachelors <dbl>, white <dbl>, black <dbl>,\n#   hispanic <dbl>, household_has_smartphone <dbl>,\n#   mean_household_income <int>, median_household_income <int>,\n#   unemployment_rate <dbl>\n```\n\n\n:::\n\n```{.r .cell-code}\ncounty_data |> select(state, name, pop, bachelors, median_household_income)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3,142 × 5\n   state   name               pop bachelors median_household_income\n   <chr>   <chr>            <int>     <dbl>                   <int>\n 1 Alabama Autauga County   55380      26.6                   58731\n 2 Alabama Baldwin County  212830      31.9                   58320\n 3 Alabama Barbour County   25361      11.6                   32525\n 4 Alabama Bibb County      22493      10.4                   47542\n 5 Alabama Blount County    57681      13.1                   49358\n 6 Alabama Bullock County   10248      12.1                   37785\n 7 Alabama Butler County    19828      16.1                   40688\n 8 Alabama Calhoun County  114618      18.5                   47255\n 9 Alabama Chambers County  33660      13.3                   42289\n10 Alabama Cherokee County  25903      12.8                   41919\n# ℹ 3,132 more rows\n```\n\n\n:::\n:::\n\n\n### Rename\n\nAnother command which might be useful for us is the `rename()` function, which allows us to rename a column (who would have thought?!?). In the code below we can see that we have renamed the \"median_household_income\" to \"med_income\". This makes it easier to reference later as we will not have to type in the long name anymore. Also notice that we start with a dataframe called `county_data`, which we then pipe a function to create a new dataframe with only 5 columns selected, which we then pipe into a function to create a new dataframe with the \"median_household_income\" column renamed. All of this to say that we can (and will) have lines of code that utilize multiple functions and pipes. It should also be noted that what we have made is a temporary dataframe, if we want to save it then we will need to save it to a variable (which we do below).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounty_data |> select(state, name, pop, bachelors, median_household_income) |> \n    rename(med_income = median_household_income)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3,142 × 5\n   state   name               pop bachelors med_income\n   <chr>   <chr>            <int>     <dbl>      <int>\n 1 Alabama Autauga County   55380      26.6      58731\n 2 Alabama Baldwin County  212830      31.9      58320\n 3 Alabama Barbour County   25361      11.6      32525\n 4 Alabama Bibb County      22493      10.4      47542\n 5 Alabama Blount County    57681      13.1      49358\n 6 Alabama Bullock County   10248      12.1      37785\n 7 Alabama Butler County    19828      16.1      40688\n 8 Alabama Calhoun County  114618      18.5      47255\n 9 Alabama Chambers County  33660      13.3      42289\n10 Alabama Cherokee County  25903      12.8      41919\n# ℹ 3,132 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\ncd1 <- county_data |> select(state, name, pop, bachelors, median_household_income) |> \n           rename(med_income = median_household_income)\n\ncd1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3,142 × 5\n   state   name               pop bachelors med_income\n   <chr>   <chr>            <int>     <dbl>      <int>\n 1 Alabama Autauga County   55380      26.6      58731\n 2 Alabama Baldwin County  212830      31.9      58320\n 3 Alabama Barbour County   25361      11.6      32525\n 4 Alabama Bibb County      22493      10.4      47542\n 5 Alabama Blount County    57681      13.1      49358\n 6 Alabama Bullock County   10248      12.1      37785\n 7 Alabama Butler County    19828      16.1      40688\n 8 Alabama Calhoun County  114618      18.5      47255\n 9 Alabama Chambers County  33660      13.3      42289\n10 Alabama Cherokee County  25903      12.8      41919\n# ℹ 3,132 more rows\n```\n\n\n:::\n:::\n\n\n### Filter\n\nThe `filter()` function will allow us to filter a dataset based on one or multiple conditions. In the code below, we want to only show the counties whose median income is greater than \\$120,000. While we could do this with index-selection brackets, using the `filter()` is probably a little easier. This does not mean that we should forget our basic R commands and logic!\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncd1[cd1$med_income > 120000,]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 8 × 5\n  state      name                   pop bachelors med_income\n  <chr>      <chr>                <int>     <dbl>      <int>\n1 California San Mateo County    767423      51       122641\n2 California Santa Clara County 1927470      52.4     124055\n3 Maryland   Howard County       318855      62.6     121160\n4 New Mexico Los Alamos County    18625      67.4     121324\n5 Virginia   Arlington County    233464      75.3     120071\n6 Virginia   Fairfax County     1145862      61.6     124831\n7 Virginia   Loudoun County      395134      61.3     142299\n8 Virginia   Falls Church city    14128      77.6     127610\n```\n\n\n:::\n\n```{.r .cell-code}\ncd1 |> filter(med_income > 120000)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 8 × 5\n  state      name                   pop bachelors med_income\n  <chr>      <chr>                <int>     <dbl>      <int>\n1 California San Mateo County    767423      51       122641\n2 California Santa Clara County 1927470      52.4     124055\n3 Maryland   Howard County       318855      62.6     121160\n4 New Mexico Los Alamos County    18625      67.4     121324\n5 Virginia   Arlington County    233464      75.3     120071\n6 Virginia   Fairfax County     1145862      61.6     124831\n7 Virginia   Loudoun County      395134      61.3     142299\n8 Virginia   Falls Church city    14128      77.6     127610\n```\n\n\n:::\n:::\n\n\nWe can pass in multiple conditionals into the command as well. Below we can see the counties with either the median income above \\$120,000 **or** (denoted by |) more than 60% having a bachelors degree. If we put a comma instead that signifies the median income above \\$120,000 **and** more than 60% having a bachelors degree.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncd1 |> filter(med_income > 120000 | bachelors > 60)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 13 × 5\n   state      name                   pop bachelors med_income\n   <chr>      <chr>                <int>     <dbl>      <int>\n 1 California San Mateo County    767423      51       122641\n 2 California Santa Clara County 1927470      52.4     124055\n 3 Colorado   Boulder County      322510      62.1      83019\n 4 Colorado   Pitkin County        17926      60.8      78935\n 5 Maryland   Howard County       318855      62.6     121160\n 6 New Mexico Los Alamos County    18625      67.4     121324\n 7 New York   New York County    1631993      61.3      86553\n 8 Virginia   Arlington County    233464      75.3     120071\n 9 Virginia   Fairfax County     1145862      61.6     124831\n10 Virginia   Loudoun County      395134      61.3     142299\n11 Virginia   Alexandria city     157613      63.1     100939\n12 Virginia   Fairfax city         23531      60.8     116979\n13 Virginia   Falls Church city    14128      77.6     127610\n```\n\n\n:::\n\n```{.r .cell-code}\ncd1 |> filter(med_income > 120000 , bachelors > 60)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 5\n  state      name                  pop bachelors med_income\n  <chr>      <chr>               <int>     <dbl>      <int>\n1 Maryland   Howard County      318855      62.6     121160\n2 New Mexico Los Alamos County   18625      67.4     121324\n3 Virginia   Arlington County   233464      75.3     120071\n4 Virginia   Fairfax County    1145862      61.6     124831\n5 Virginia   Loudoun County     395134      61.3     142299\n6 Virginia   Falls Church city   14128      77.6     127610\n```\n\n\n:::\n:::\n\n\n### Mutate\n\nIf we wish to alter (some may even say mutate) the dataset then we can use the `mutate()` function to accomplish this task. The function allows us to create a new column based on some value or some expression. If we want to alter a column that already exists then we can reference the column and it will be overwritten. In the example below we create a new column to calculate the percentage of people in the county who do not have a bachelors degree.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\ncd1 |> filter(med_income > 120000 , bachelors > 60) |>\n    mutate(no_bach = 100 - bachelors)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 6\n  state      name                  pop bachelors med_income no_bach\n  <chr>      <chr>               <int>     <dbl>      <int>   <dbl>\n1 Maryland   Howard County      318855      62.6     121160    37.4\n2 New Mexico Los Alamos County   18625      67.4     121324    32.6\n3 Virginia   Arlington County   233464      75.3     120071    24.7\n4 Virginia   Fairfax County    1145862      61.6     124831    38.4\n5 Virginia   Loudoun County     395134      61.3     142299    38.7\n6 Virginia   Falls Church city   14128      77.6     127610    22.4\n```\n\n\n:::\n:::\n\n\n### Arrange\n\nOccasionally we might want to sort a dataset so that the values are in order from least to greatest (or greatest to least). To do this we can use the `arrange()` function. It should be noted that we can arrange on multiple variables, meaning if there is a tie in the first variable then the next variable is used to sort as the tie break. If we want to put the items in decreasing order then we can specify that by using the `desc()` function. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ncd1 |> filter(med_income > 120000 , bachelors > 60) |>\n    mutate(no_bach = 100 - bachelors) |>\n    arrange(desc(pop))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 6\n  state      name                  pop bachelors med_income no_bach\n  <chr>      <chr>               <int>     <dbl>      <int>   <dbl>\n1 Virginia   Fairfax County    1145862      61.6     124831    38.4\n2 Virginia   Loudoun County     395134      61.3     142299    38.7\n3 Maryland   Howard County      318855      62.6     121160    37.4\n4 Virginia   Arlington County   233464      75.3     120071    24.7\n5 New Mexico Los Alamos County   18625      67.4     121324    32.6\n6 Virginia   Falls Church city   14128      77.6     127610    22.4\n```\n\n\n:::\n:::\n\n\n### Summarise\n\nA common task we might encounter as data scientists is to calculate different statistics to learn more about the dataset. To do this, we can use the `summarise()` function. We can pass multiple statistics we want to calculate into the function. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ncd1 |> summarise(total_pop = sum(pop), avg_income = mean(med_income))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 2\n  total_pop avg_income\n      <int>      <dbl>\n1 324697795     53476.\n```\n\n\n:::\n:::\n\n\n### Group By\n\nCalculating statistics on a whole dataset is nice, but it is also beneficial to calculate the statistics based on some categorical characteristic within the dataset. To do this we can use the `group_by()` function which (behind the scenes) will essentially make small datasets for each characteristic. Using the `summarise()` with this allows us to make calculations on each group. In the example below we calculate the total population for each state along with the average median income level for each state. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ncd1 |> group_by(state) |>\n    summarise(total_pop = sum(pop), avg_income = mean(med_income))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 51 × 3\n   state                total_pop avg_income\n   <chr>                    <int>      <dbl>\n 1 Alabama                4876250     43575.\n 2 Alaska                  737068     67789.\n 3 Arizona                7050299     48990.\n 4 Arkansas               2999370     42237.\n 5 California            39283497     67714.\n 6 Colorado               5610349     58795.\n 7 Connecticut            3575074     79201.\n 8 Delaware                957248     65988 \n 9 District of Columbia    692683     86420 \n10 Florida               20901636     51290.\n# ℹ 41 more rows\n```\n\n\n:::\n:::\n\n\n\n## Tidyr\n\nWhen dealing with data, it is important to be able to manipulate the data into a \"usable\" format. This is often referred to as making sure the data is \"tidy\", meaning each column is a variable, each row is an observation, and each cell has a single value. To accomplish this task we will use the `tidyr` library. First though, lets look at the `population` dataset that we will be working with. I have filtered it so only the first 5 years are present for each country.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npop1 <- population |> filter(year %in% c(1995,1996,1997,1998,1999))\npop1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,060 × 3\n   country      year population\n   <chr>       <dbl>      <dbl>\n 1 Afghanistan  1995   17586073\n 2 Afghanistan  1996   18415307\n 3 Afghanistan  1997   19021226\n 4 Afghanistan  1998   19496836\n 5 Afghanistan  1999   19987071\n 6 Albania      1995    3357858\n 7 Albania      1996    3341043\n 8 Albania      1997    3331317\n 9 Albania      1998    3325456\n10 Albania      1999    3317941\n# ℹ 1,050 more rows\n```\n\n\n:::\n:::\n\n\n### Pivot Wider\n\nAs we can see that the dataset is not tidy because the information for one observation (a country) is spread across multiple rows. We’d like all of a country’s values to live on the same row. To fix this we can do what we call \"pivoting wider\". This will take the take the categorical data in a single column and turn it into column headers while the values from  the other column are matched up to the observation and column header. In the code below we first use the `mutate()` and `unite()` function to alter the years so that a letter is present, this is because column names cannot start with a number in R unless we put them in quotes. To avoid constantly typing quotes later, we’re prepending a ‘y’ to the year.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npop1 |> mutate(y=\"y\") |> unite(\"year\", c(y, year)) |>\n    pivot_wider(names_from = year, values_from = population)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 212 × 6\n   country               y_1995   y_1996   y_1997   y_1998   y_1999\n   <chr>                  <dbl>    <dbl>    <dbl>    <dbl>    <dbl>\n 1 Afghanistan         17586073 18415307 19021226 19496836 19987071\n 2 Albania              3357858  3341043  3331317  3325456  3317941\n 3 Algeria             29315463 29845208 30345466 30820435 31276295\n 4 American Samoa         52874    53926    54942    55899    56768\n 5 Andorra                63854    64274    64090    63799    64084\n 6 Angola              12104952 12451945 12791388 13137542 13510616\n 7 Anguilla                9807    10063    10305    10545    10797\n 8 Antigua and Barbuda    68349    70245    72232    74206    76041\n 9 Argentina           34833168 35264070 35690778 36109342 36514558\n10 Armenia              3223173  3173425  3137652  3112958  3093820\n# ℹ 202 more rows\n```\n\n\n:::\n:::\n\nWe would consider the output above to now be tidy because all values associated with a country are now in the same row. \n\n### Pivot Longer\n\nSince pivoting wider takes values in a column and turns them into column headers, pivoting longer will take the column headers the transform them into columns themselves. Notice that pivot_longer takes the year columns (y_1995, y_1996, ...) and stacks them into two columns: one for year and one for population. This gets us back to the original tall format. \n\n\n::: {.cell}\n\n```{.r .cell-code}\npop1 |> mutate(y=\"y\") |> unite(\"year\", c(y, year)) |>\n    pivot_wider(names_from = year, values_from = population) |>\n    pivot_longer(y_1995:y_1999, names_to = \"year\", values_to = \"population\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,060 × 3\n   country     year   population\n   <chr>       <chr>       <dbl>\n 1 Afghanistan y_1995   17586073\n 2 Afghanistan y_1996   18415307\n 3 Afghanistan y_1997   19021226\n 4 Afghanistan y_1998   19496836\n 5 Afghanistan y_1999   19987071\n 6 Albania     y_1995    3357858\n 7 Albania     y_1996    3341043\n 8 Albania     y_1997    3331317\n 9 Albania     y_1998    3325456\n10 Albania     y_1999    3317941\n# ℹ 1,050 more rows\n```\n\n\n:::\n:::\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}